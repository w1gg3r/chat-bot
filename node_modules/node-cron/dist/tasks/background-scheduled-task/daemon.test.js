"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const daemon_1 = require("./daemon");
describe('daemon - register', function () {
    let messages = [];
    const listeners = [];
    beforeEach(() => {
        process.send = (message) => {
            messages.push(message);
            return true;
        };
        process.on = (event, fn) => {
            listeners.push({ event, fn });
            return process;
        };
    });
    it('should register a task', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const message = {
                command: 'task:start',
                path: '../../../test-assets/dummy-task.js',
                cron: '* * * * * *',
                options: { name: 'dummy-task' },
            };
            (0, daemon_1.bind)();
            const onMessge = listeners.find(l => l.event === 'message');
            const task = yield onMessge.fn(message);
            chai_1.assert.isDefined(task);
            chai_1.assert.equal(task.name, 'dummy-task');
            task.destroy();
        });
    });
    it('should send all events', function () {
        return __awaiter(this, void 0, void 0, function* () {
            messages = [];
            const message = {
                command: 'task:start',
                path: '../../../test-assets/dummy-task.js',
                cron: '* * * * * *',
                options: { name: 'dummy-task' },
            };
            (0, daemon_1.bind)();
            const onMessge = listeners.find(l => l.event === 'message');
            const task = yield onMessge.fn(message);
            task.start();
            yield new Promise(r => setTimeout(() => { r(true); }, 1000));
            task.destroy();
            const expectedEvents = [
                'daemon:started',
                'task:started',
                'execution:started',
                'execution:finished',
                'task:stopped',
                'task:destroyed'
            ];
            const receivedEvents = messages.map(msg => msg.event);
            expectedEvents.forEach(expectedEvent => {
                chai_1.assert.ok(receivedEvents.includes(expectedEvent), `Event '${expectedEvent}' not received. Events received: ${receivedEvents.join(', ')}`);
            });
        });
    });
    it('should send error event', function () {
        return __awaiter(this, void 0, void 0, function* () {
            messages = [];
            const message = {
                command: 'task:start',
                path: '../../../test-assets/failing-task.js',
                cron: '* * * * * *',
                options: { name: 'failing-task' },
            };
            (0, daemon_1.bind)();
            const onMessge = listeners.find(l => l.event === 'message');
            const task = yield onMessge.fn(message);
            task.start();
            yield new Promise(r => setTimeout(() => { r(true); }, 1000));
            task.destroy();
            chai_1.assert.equal(messages[0].event, 'daemon:started');
            chai_1.assert.equal(messages[1].event, 'task:started');
            chai_1.assert.equal(messages[2].event, 'execution:started');
            chai_1.assert.equal(messages[3].event, 'execution:failed');
        });
    });
    it('should send overlap event', function () {
        return __awaiter(this, void 0, void 0, function* () {
            messages = [];
            const message = {
                command: 'task:start',
                path: '../../../test-assets/two-seconds-task.js',
                cron: '* * * * * *',
                options: { name: 'two-seconds-task' },
            };
            (0, daemon_1.bind)();
            const onMessge = listeners.find(l => l.event === 'message');
            const task = yield onMessge.fn(message);
            task.start();
            yield new Promise(r => setTimeout(() => { r(true); }, 2000));
            task.destroy();
            chai_1.assert.equal(messages[0].event, 'daemon:started');
            chai_1.assert.equal(messages[1].event, 'task:started');
            chai_1.assert.equal(messages[2].event, 'execution:started');
            chai_1.assert.equal(messages[3].event, 'execution:overlap');
        });
    }).timeout(5000);
    it('should send missed event', function () {
        return __awaiter(this, void 0, void 0, function* () {
            messages = [];
            const message = {
                command: 'task:start',
                path: '../../../test-assets/dummy-task.js',
                cron: '* * * * * *',
                options: { name: 'missed-task' },
            };
            (0, daemon_1.bind)();
            const onMessge = listeners.find(l => l.event === 'message');
            const task = yield onMessge.fn(message);
            task.start();
            yield new Promise(resolve => { setTimeout(resolve, 1000); });
            blockIO(2000);
            yield new Promise(resolve => { setTimeout(resolve, 1200); });
            task.destroy();
            const event = messages.find(m => m.event === 'execution:missed');
            chai_1.assert.isDefined(event);
        });
    }).timeout(6000);
    it('should handle task:stop command', function () {
        return __awaiter(this, void 0, void 0, function* () {
            messages = [];
            const message = {
                command: 'task:start',
                path: '../../../test-assets/two-seconds-task.js',
                cron: '* * * * * *',
                options: { name: 'two-seconds-task' },
            };
            (0, daemon_1.bind)();
            const onMessge = listeners.find(l => l.event === 'message');
            const task = yield onMessge.fn(message);
            yield task.start();
            const onMessage = listeners.find(l => l.event === 'message');
            const stopMessage = { command: 'task:stop' };
            const result = yield onMessage.fn(stopMessage);
            chai_1.assert.equal(result, task);
            const stoppedEvent = messages.find(m => m.event === 'task:stopped');
            chai_1.assert.isDefined(stoppedEvent, 'task:stopped event should be sent');
            task.destroy();
        });
    });
    it('should handle task:destroy command', function () {
        return __awaiter(this, void 0, void 0, function* () {
            messages = [];
            const message = {
                command: 'task:start',
                path: '../../../test-assets/two-seconds-task.js',
                cron: '* * * * * *',
                options: { name: 'two-seconds-task' },
            };
            (0, daemon_1.bind)();
            const onMessge = listeners.find(l => l.event === 'message');
            const task = yield onMessge.fn(message);
            yield task.start();
            const onMessage = listeners.find(l => l.event === 'message');
            const destroyMessage = { command: 'task:destroy' };
            const result = yield onMessage.fn(destroyMessage);
            chai_1.assert.equal(result, task);
            const destroyedEvent = messages.find(m => m.event === 'task:destroyed');
            chai_1.assert.isDefined(destroyedEvent, 'task:destroyed event should be sent');
            task.destroy();
        });
    });
    it('should handle task:execute command', function () {
        return __awaiter(this, void 0, void 0, function* () {
            messages = [];
            const message = {
                command: 'task:start',
                path: '../../../test-assets/two-seconds-task.js',
                cron: '* * * * * *',
                options: { name: 'two-seconds-task' },
            };
            (0, daemon_1.bind)();
            const onMessge = listeners.find(l => l.event === 'message');
            const task = yield onMessge.fn(message);
            yield task.start();
            const onMessage = listeners.find(l => l.event === 'message');
            const executeMessage = { command: 'task:execute' };
            yield onMessage.fn(executeMessage);
            const startedEvent = messages.find(m => m.event === 'execution:started');
            chai_1.assert.isDefined(startedEvent, 'execution:started event should be sent');
            const finishedEvent = messages.find(m => m.event === 'execution:finished');
            chai_1.assert.isDefined(finishedEvent, 'execution:finished event should be sent');
            task.destroy();
        });
    }).timeout(10000);
    ;
    it('should handle task:execute command with error', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const message = {
                command: 'task:start',
                path: '../../../test-assets/failing-task.js',
                cron: '* * * * * *',
                options: { name: 'failing-task' },
            };
            (0, daemon_1.bind)();
            const onMessage = listeners.find(l => l.event === 'message');
            const task = yield onMessage.fn(message);
            yield task.start();
            messages = [];
            const executeMessage = { command: 'task:execute' };
            yield onMessage.fn(executeMessage);
            const failedEvent = messages.find(m => m.event === 'execution:failed');
            chai_1.assert.isDefined(failedEvent, 'execution:failed event should be sent');
            chai_1.assert.isDefined(failedEvent.jsonError, 'error should be serialized');
            chai_1.assert.equal(JSON.parse(failedEvent.jsonError).extra, 'extra');
            task.destroy();
        });
    }).timeout(10000);
});
function blockIO(ms) {
    const start = Date.now();
    while (Date.now() - start < ms)
        ;
}
//# sourceMappingURL=daemon.test.js.map