"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const inline_scheduled_task_1 = require("./inline-scheduled-task");
describe('InlineScheduledTask', function () {
    it('builds with default values', function () {
        const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => { });
        chai_1.assert.isTrue(task.id.startsWith('task-'));
        chai_1.assert.equal(task.id, task.name);
        chai_1.assert.isDefined(task.runner);
        chai_1.assert.equal(task.getStatus(), 'stopped');
    });
    it('starts', function () {
        const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => { });
        task.start();
        chai_1.assert.equal(task.getStatus(), 'idle');
        task.destroy();
    });
    it('returns next run', function () {
        var _a;
        const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * *', () => { });
        task.start();
        const nextMinute = new Date();
        nextMinute.setMilliseconds(0);
        nextMinute.setSeconds(0);
        nextMinute.setMinutes(nextMinute.getMinutes() + 1);
        chai_1.assert.equal((_a = task.getNextRun()) === null || _a === void 0 ? void 0 : _a.getTime(), nextMinute.getTime());
        task.destroy();
    });
    it('stops', function () {
        const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => { });
        task.start();
        chai_1.assert.equal(task.getStatus(), 'idle');
        task.stop();
        chai_1.assert.equal(task.getStatus(), 'stopped');
        task.destroy();
    });
    it('destroys', function () {
        const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => { });
        task.start();
        chai_1.assert.equal(task.getStatus(), 'idle');
        task.destroy();
        chai_1.assert.equal(task.getStatus(), 'destroyed');
    });
    it('executes', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => __awaiter(this, void 0, void 0, function* () { return "task result"; }));
            const result = yield task.execute();
            chai_1.assert.equal(result, "task result");
        });
    });
    it('executes and fails', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => __awaiter(this, void 0, void 0, function* () { throw new Error("task error"); }));
            try {
                yield task.execute();
                chai_1.assert.fail('should fail before');
            }
            catch (error) {
                chai_1.assert.equal(error.message, 'task error');
            }
        });
    });
    it('emmits task:started', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => __awaiter(this, void 0, void 0, function* () { return "task result"; }));
            const eventCaught = new Promise(resolve => {
                task.on('task:started', (event) => {
                    resolve(event);
                });
            });
            task.start();
            const event = yield eventCaught;
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.date);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.triggeredAt);
            task.destroy();
        });
    });
    it('emmits task:stopped', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => __awaiter(this, void 0, void 0, function* () { return "task result"; }));
            const eventCaught = new Promise(resolve => {
                task.on('task:stopped', (event) => {
                    resolve(event);
                });
            });
            task.start();
            task.stop();
            const event = yield eventCaught;
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.date);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.triggeredAt);
            task.destroy();
        });
    });
    it('emmits task:destroyed', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => __awaiter(this, void 0, void 0, function* () { return "task result"; }));
            const eventCaught = new Promise(resolve => {
                task.on('task:destroyed', (event) => {
                    resolve(event);
                });
            });
            task.destroy();
            const event = yield eventCaught;
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.date);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.triggeredAt);
        });
    });
    it('emmits execution:started', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => __awaiter(this, void 0, void 0, function* () { return "task result"; }));
            const eventCaught = new Promise(resolve => {
                task.on('execution:started', (event) => {
                    resolve(event);
                });
            });
            task.start();
            const event = yield eventCaught;
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.date);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.triggeredAt);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.execution);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.execution.id);
            chai_1.assert.isUndefined(event === null || event === void 0 ? void 0 : event.execution.result);
            task.destroy();
        });
    });
    it('emmits execution:finished', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => __awaiter(this, void 0, void 0, function* () { return "task result"; }));
            const eventCaught = new Promise(resolve => {
                task.on('execution:finished', (event) => {
                    resolve(event);
                });
            });
            task.start();
            const event = yield eventCaught;
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.date);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.triggeredAt);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.execution);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.execution.id);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.execution.result);
            chai_1.assert.isUndefined(event === null || event === void 0 ? void 0 : event.execution.error);
            task.destroy();
        });
    });
    it('emmits execution:failed', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => __awaiter(this, void 0, void 0, function* () { throw new Error("task result"); }));
            const eventCaught = new Promise(resolve => {
                task.on('execution:failed', (event) => {
                    resolve(event);
                });
            });
            task.start();
            const event = yield eventCaught;
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.date);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.triggeredAt);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.execution);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.execution.id);
            chai_1.assert.isUndefined(event === null || event === void 0 ? void 0 : event.execution.result);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.execution.error);
            task.destroy();
        });
    });
    it('emmits execution:overlap', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => __awaiter(this, void 0, void 0, function* () { yield new Promise(r => setTimeout(r, 2000)); }));
            const eventCaught = new Promise(resolve => {
                task.on('execution:overlap', (event) => {
                    resolve(event);
                });
            });
            task.start();
            const event = yield eventCaught;
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.date);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.triggeredAt);
            task.destroy();
        });
    });
    it('emmits execution:missed', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => __awaiter(this, void 0, void 0, function* () { return "task result"; }));
            const eventCaught = new Promise(resolve => {
                task.on('execution:missed', (event) => {
                    resolve(event);
                });
            });
            task.start();
            yield new Promise(resolve => { setTimeout(resolve, 1000); });
            blockIO(2000);
            yield new Promise(resolve => { setTimeout(resolve, 1200); });
            const event = yield eventCaught;
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.date);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.triggeredAt);
            task.destroy();
        });
    }).timeout(5000);
    it('emmits execution:maxReached', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const task = new inline_scheduled_task_1.InlineScheduledTask('* * * * * *', () => __awaiter(this, void 0, void 0, function* () { return "task result"; }), { maxExecutions: 1 });
            const eventCaught = new Promise(resolve => {
                task.on('execution:maxReached', (event) => {
                    resolve(event);
                });
            });
            task.start();
            yield new Promise(resolve => { setTimeout(resolve, 1000); });
            const event = yield eventCaught;
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.date);
            chai_1.assert.isDefined(event === null || event === void 0 ? void 0 : event.triggeredAt);
            task.destroy();
        });
    }).timeout(5000);
});
function blockIO(ms) {
    const start = Date.now();
    while (Date.now() - start < ms)
        ;
}
//# sourceMappingURL=inline-scheduled-task.test.js.map