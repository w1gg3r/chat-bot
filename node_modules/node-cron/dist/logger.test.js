"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon_1 = __importDefault(require("sinon"));
const logger_1 = __importDefault(require("./logger"));
describe('Logger', () => {
    let consoleInfoStub;
    let consoleDebugStub;
    let consoleWarnStub;
    let consoleErrorStub;
    beforeEach(() => {
        // Replace console methods with stubs
        consoleInfoStub = sinon_1.default.stub(console, 'info');
        consoleDebugStub = sinon_1.default.stub(console, 'debug');
        consoleWarnStub = sinon_1.default.stub(console, 'warn');
        consoleErrorStub = sinon_1.default.stub(console, 'error');
    });
    afterEach(() => {
        // Restore original console methods
        consoleInfoStub.restore();
        consoleWarnStub.restore();
        consoleErrorStub.restore();
        consoleDebugStub.restore();
    });
    describe('info', () => {
        it('should call console.log with properly formatted message', () => {
            const message = 'Information test';
            logger_1.default.info(message);
            chai_1.assert.isTrue(consoleInfoStub.calledOnce);
            const loggedMessage = consoleInfoStub.firstCall.args[0];
            // Basic format checks
            chai_1.assert.include(loggedMessage, '[INFO]');
            chai_1.assert.include(loggedMessage, '[NODE-CRON]');
            chai_1.assert.include(loggedMessage, message);
        });
    });
    describe('warn', () => {
        it('should call console.warn with properly formatted message', () => {
            const message = 'Warning test';
            logger_1.default.warn(message);
            chai_1.assert.isTrue(consoleWarnStub.calledOnce);
            const loggedMessage = consoleWarnStub.firstCall.args[0];
            chai_1.assert.include(loggedMessage, '[WARN]');
            chai_1.assert.include(loggedMessage, '[NODE-CRON]');
            chai_1.assert.include(loggedMessage, message);
        });
    });
    describe('error', () => {
        it('should call console.error with properly formatted message when passed string', () => {
            const message = 'Error test';
            logger_1.default.error(message);
            chai_1.assert.isTrue(consoleErrorStub.calledOnce);
            const loggedMessage = consoleErrorStub.firstCall.args[0];
            chai_1.assert.include(loggedMessage, '[ERROR]');
            chai_1.assert.include(loggedMessage, '[NODE-CRON]');
            chai_1.assert.include(loggedMessage, message);
        });
        it('should call console.error with properly formatted message when passed Error object', () => {
            const error = new Error('Error object test');
            logger_1.default.error(error);
            chai_1.assert.isTrue(consoleErrorStub.calledOnce);
            const loggedMessage = consoleErrorStub.firstCall.args[0];
            const loggedError = consoleErrorStub.firstCall.args[1];
            chai_1.assert.include(loggedMessage, '[ERROR]');
            chai_1.assert.include(loggedMessage, '[NODE-CRON]');
            chai_1.assert.include(loggedMessage, error.message);
            chai_1.assert.strictEqual(loggedError, error);
        });
        it('should call console.error with properly formatted message and additional error', () => {
            const message = 'Primary error message';
            const additionalError = new Error('Additional error details');
            logger_1.default.error(message, additionalError);
            chai_1.assert.isTrue(consoleErrorStub.calledOnce);
            const loggedMessage = consoleErrorStub.firstCall.args[0];
            const loggedError = consoleErrorStub.firstCall.args[1];
            chai_1.assert.include(loggedMessage, '[ERROR]');
            chai_1.assert.include(loggedMessage, '[NODE-CRON]');
            chai_1.assert.include(loggedMessage, message);
            chai_1.assert.strictEqual(loggedError, additionalError);
        });
    });
    describe('debug', () => {
        it('should call console.log with properly formatted message when passed string', () => {
            const message = 'Debug test';
            logger_1.default.debug(message);
            chai_1.assert.isTrue(consoleDebugStub.calledOnce);
            const loggedMessage = consoleDebugStub.firstCall.args[0];
            chai_1.assert.include(loggedMessage, '[DEBUG]');
            chai_1.assert.include(loggedMessage, '[NODE-CRON]');
            chai_1.assert.include(loggedMessage, message);
        });
        it('should call console.log with properly formatted message when passed Error object', () => {
            const error = new Error('Debug error test');
            logger_1.default.debug(error);
            chai_1.assert.isTrue(consoleDebugStub.calledOnce);
            const loggedMessage = consoleDebugStub.firstCall.args[0];
            const loggedError = consoleDebugStub.firstCall.args[1];
            chai_1.assert.include(loggedMessage, '[DEBUG]');
            chai_1.assert.include(loggedMessage, '[NODE-CRON]');
            chai_1.assert.include(loggedMessage, error.message);
            chai_1.assert.strictEqual(loggedError, error);
        });
        it('should call console.log with properly formatted message and additional error', () => {
            const message = 'Primary debug message';
            const additionalError = new Error('Additional debug details');
            logger_1.default.debug(message, additionalError);
            chai_1.assert.isTrue(consoleDebugStub.calledOnce);
            const loggedMessage = consoleDebugStub.firstCall.args[0];
            const loggedError = consoleDebugStub.firstCall.args[1];
            chai_1.assert.include(loggedMessage, '[DEBUG]');
            chai_1.assert.include(loggedMessage, '[NODE-CRON]');
            chai_1.assert.include(loggedMessage, message);
            chai_1.assert.strictEqual(loggedError, additionalError);
        });
    });
    describe('log function', () => {
        it('should correctly format timestamp and process ID', () => {
            const message = 'Timestamp test';
            logger_1.default.info(message);
            chai_1.assert.isTrue(consoleInfoStub.calledOnce);
            const loggedMessage = consoleInfoStub.firstCall.args[0];
            // Check for timestamp and PID format
            chai_1.assert.match(loggedMessage, /\[\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z\]/); // ISO timestamp format
            chai_1.assert.match(loggedMessage, /\[PID: \d+\]/); // Process ID format
        });
        it('should use correct colors for different log levels', () => {
            // This is a limited test since we can't easily check ANSI color codes in the output
            // But we can at least ensure the log function is called correctly
            logger_1.default.info('Info message');
            logger_1.default.warn('Warn message');
            logger_1.default.error('Error message');
            logger_1.default.debug('Debug message');
            chai_1.assert.isTrue(consoleInfoStub.calledOnce);
            chai_1.assert.isTrue(consoleWarnStub.calledOnce);
            chai_1.assert.isTrue(consoleErrorStub.calledOnce);
            chai_1.assert.isTrue(consoleDebugStub.calledOnce);
        });
    });
});
//# sourceMappingURL=logger.test.js.map