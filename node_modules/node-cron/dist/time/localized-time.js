"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalizedTime = void 0;
class LocalizedTime {
    constructor(date, timezone) {
        this.timestamp = date.getTime();
        this.timezone = timezone;
        this.parts = buidDateParts(date, timezone);
    }
    toDate() {
        return new Date(this.timestamp);
    }
    toISO() {
        const gmt = this.parts.gmt.replace(/^GMT/, '');
        const offset = gmt ? gmt : 'Z';
        const pad = (n) => String(n).padStart(2, '0');
        return `${this.parts.year}-${pad(this.parts.month)}-${pad(this.parts.day)}`
            + `T${pad(this.parts.hour)}:${pad(this.parts.minute)}:${pad(this.parts.second)}`
            + `.${String(this.parts.milisecond).padStart(3, '0')}`
            + offset;
    }
    getParts() {
        return this.parts;
    }
    set(field, value) {
        this.parts[field] = value;
        const newDate = new Date(this.toISO());
        this.timestamp = newDate.getTime();
        this.parts = buidDateParts(newDate, this.timezone);
    }
}
exports.LocalizedTime = LocalizedTime;
function buidDateParts(date, timezone) {
    const dftOptions = {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        weekday: 'short',
        hour12: false,
        timeZoneName: 'longOffset'
    };
    if (timezone) {
        dftOptions.timeZone = timezone;
    }
    const dateFormat = new Intl.DateTimeFormat('en-US', dftOptions);
    const parts = dateFormat.formatToParts(date).filter(part => {
        return part.type !== 'literal';
    }).reduce((acc, part) => {
        acc[part.type] = part.value;
        return acc;
    }, {});
    return {
        day: parseInt(parts.day),
        month: parseInt(parts.month),
        year: parseInt(parts.year),
        hour: parseInt(parts.hour),
        minute: parseInt(parts.minute),
        second: parseInt(parts.second),
        milisecond: date.getMilliseconds(),
        weekday: parts.weekday,
        gmt: parts.timeZoneName
    };
}
//# sourceMappingURL=localized-time.js.map