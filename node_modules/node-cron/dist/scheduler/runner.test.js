"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const runner_1 = require("./runner");
const time_matcher_1 = require("../time/time-matcher");
const logger_1 = __importDefault(require("../logger"));
describe('scheduler/runner', function () {
    it('starts running', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const timeMatcher = new time_matcher_1.TimeMatcher('* * * * * *');
            const runner = createRunner(timeMatcher, 200);
            chai_1.assert.isFalse(runner.isStarted());
            chai_1.assert.isTrue(runner.isStopped());
            runner.start();
            chai_1.assert.isTrue(runner.isStarted());
            chai_1.assert.isFalse(runner.isStopped());
            yield new Promise(resolve => { setTimeout(resolve, 1000); });
            runner.stop();
            chai_1.assert.isTrue(runner.runCount >= 1);
        });
    }).timeout(3000);
    it('allows handle task finished', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const timeMatcher = new time_matcher_1.TimeMatcher('* * * * * *');
            const resultCaught = new Promise((resolve) => {
                const runner = new runner_1.Runner(timeMatcher, () => __awaiter(this, void 0, void 0, function* () {
                    return 'task finished';
                }), {
                    onFinished(date, execution) {
                        resolve(execution.result);
                        runner.stop();
                        return true;
                    }
                });
                runner.start();
            });
            const result = yield resultCaught;
            chai_1.assert.equal(result, 'task finished');
        });
    }).timeout(3000);
    it('allows handle before execute', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const timeMatcher = new time_matcher_1.TimeMatcher('* * * * * *');
            const resultCaught = new Promise((resolve) => {
                const runner = new runner_1.Runner(timeMatcher, () => __awaiter(this, void 0, void 0, function* () {
                    return 'task finished';
                }), {
                    beforeRun() {
                        return __awaiter(this, void 0, void 0, function* () {
                            return true;
                        });
                    },
                    onFinished(date, execution) {
                        resolve(execution.result);
                        runner.stop();
                        return true;
                    }
                });
                runner.start();
            });
            const result = yield resultCaught;
            chai_1.assert.equal(result, 'task finished');
        });
    });
    it('allows manual execution', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const timeMatcher = new time_matcher_1.TimeMatcher('* * * * * *');
            const resultCaught = new Promise((resolve) => {
                const runner = new runner_1.Runner(timeMatcher, () => __awaiter(this, void 0, void 0, function* () {
                    return 'task finished';
                }), {
                    beforeRun() {
                        return __awaiter(this, void 0, void 0, function* () {
                            return true;
                        });
                    },
                    onFinished(date, execution) {
                        resolve(execution.result);
                        runner.stop();
                        return true;
                    }
                });
                runner.execute();
            });
            const result = yield resultCaught;
            chai_1.assert.equal(result, 'task finished');
        });
    });
    it('allows handle task error on manual execution', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const timeMatcher = new time_matcher_1.TimeMatcher('* * * * * *');
            const errorCaught = new Promise((resolve) => {
                const runner = new runner_1.Runner(timeMatcher, () => __awaiter(this, void 0, void 0, function* () {
                    throw new Error('task failed');
                }), {
                    onError(date, err) {
                        resolve(err);
                        runner.stop();
                    }
                });
                runner.execute();
            });
            const error = yield errorCaught;
            chai_1.assert.equal(error.message, 'task failed');
        });
    }).timeout(3000);
    it('before execute prevents run', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const timeMatcher = new time_matcher_1.TimeMatcher('* * * * * *');
            let boforeCalled = false;
            const runner = new runner_1.Runner(timeMatcher, () => __awaiter(this, void 0, void 0, function* () {
                return 'task finished';
            }), {
                beforeRun() {
                    boforeCalled = true;
                    return false;
                }
            });
            runner.start();
            yield new Promise(resolve => { setTimeout(resolve, 1000); });
            runner.stop();
            chai_1.assert.isTrue(boforeCalled);
            chai_1.assert.equal(runner.runCount, 0);
        });
    });
    it('allows handle task error', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const timeMatcher = new time_matcher_1.TimeMatcher('* * * * * *');
            const errorCaught = new Promise((resolve) => {
                const runner = new runner_1.Runner(timeMatcher, () => __awaiter(this, void 0, void 0, function* () {
                    throw new Error('task failed');
                }), {
                    onError(date, err) {
                        resolve(err);
                        runner.stop();
                    }
                });
                runner.start();
            });
            const error = yield errorCaught;
            chai_1.assert.equal(error.message, 'task failed');
        });
    }).timeout(3000);
    it('does not break if onError was not set', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const preError = logger_1.default.error;
            new Promise(resolve => {
                const timeMatcher = new time_matcher_1.TimeMatcher('* * * * * *');
                const runner = new runner_1.Runner(timeMatcher, () => __awaiter(this, void 0, void 0, function* () {
                    throw new Error('task failed');
                }));
                logger_1.default.error = (err) => {
                    resolve(err);
                    runner.stop();
                    logger_1.default.error = preError;
                };
                runner.start();
            });
        });
    }).timeout(3000);
    it('returns next run', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const timeMatcher = new time_matcher_1.TimeMatcher('* * * * *');
            const runner = createRunner(timeMatcher, 200);
            const now = new Date();
            runner.start();
            const nextRun = runner.nextRun();
            chai_1.assert.equal(nextRun.getMinutes(), now.getMinutes() + 1);
            runner.stop();
        });
    }).timeout(3000);
    it('prevents overlap', function (done) {
        const timeMatcher = new time_matcher_1.TimeMatcher('* * * * * *');
        const onOverlap = (date) => {
            try {
                runner.stop();
                chai_1.assert.isDefined(date);
                chai_1.assert.equal(runner.runCount, 1);
                done();
            }
            catch (error) {
                done(error);
            }
        };
        const runner = createRunner(timeMatcher, 1200, { noOverlap: true, onOverlap: onOverlap });
        runner.start();
    }).timeout(5000);
    it('prevents overlap without setting an onOverlap function', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const timeMatcher = new time_matcher_1.TimeMatcher('* * * * * *');
            const runner = createRunner(timeMatcher, 1500, { noOverlap: true });
            runner.start();
            yield new Promise(resolve => { setTimeout(resolve, 2000); });
            chai_1.assert.equal(runner.runCount, 1);
            runner.stop();
        });
    }).timeout(5000);
    it('when prevents overlap function failing', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const timeMatcher = new time_matcher_1.TimeMatcher('* * * * * *');
            const runner = createRunner(timeMatcher, 1200, { noOverlap: true, onOverlap: () => { throw new Error('fail!'); } });
            runner.start();
            yield new Promise(resolve => { setTimeout(resolve, 2000); });
            runner.stop();
        });
    }).timeout(5000);
    it('detects blocking IO', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const timeMatcher = new time_matcher_1.TimeMatcher('* * * * * *');
            let missedDate = null;
            let missedCount = 0;
            const onMissedExecution = (date) => { missedDate = date; missedCount++; };
            const runner = createRunner(timeMatcher, 200, { onMissedExecution: onMissedExecution });
            runner.start();
            yield new Promise(resolve => { setTimeout(resolve, 1000); });
            blockIO(2000);
            yield new Promise(resolve => { setTimeout(resolve, 1200); });
            runner.stop();
            chai_1.assert.isNotNull(missedDate);
            chai_1.assert.equal(missedCount, 1);
        });
    }).timeout(10000);
});
function blockIO(ms) {
    const start = Date.now();
    while (Date.now() - start < ms)
        ;
}
function createRunner(timeMatcher, delay, options) {
    return new runner_1.Runner(timeMatcher, () => __awaiter(this, void 0, void 0, function* () {
        yield new Promise(resolve => { setTimeout(resolve, delay); });
    }), options);
}
//# sourceMappingURL=runner.test.js.map